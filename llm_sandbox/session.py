import os\\\nimport tarfile\\\\nimport docker\\\\nimport io\\\\nimport unittest\\\\nimport patch\\\\nimport MagicMock\\\\nimport unittest.main\\\\n\\\\\nfrom typing import Optional, List, Union\\\\nfrom docker.models.images import Image\\\\nfrom docker.models.containers import Container\\\\nfrom llm_sandbox.utils import (\\\\n    image_exists,\\\\\n    get_libraries_installation_command,\\\\\n    get_code_file_extension,\\\\\n    get_code_execution_command\\\\n)\\\\nfrom llm_sandbox.const import SupportedLanguage, DefaultImage, NotSupportedLibraryInstallation\\\\nfrom docker.from_env import DockerClient\\\\n\\\\\nclass SandboxSession:\\\\n    def __init__(self,\\\\\n        image: Optional[str] = None,\\\\\n        dockerfile: Optional[str] = None,\\\\\n        lang: str = SupportedLanguage.PYTHON,\\\\\n        keep_template: bool = False,\\\\\n        verbose: bool = True\\\\n    ):\\\\\\\\n        if image and dockerfile:\\\\\\\n            raise ValueError("Only one of image or dockerfile should be provided")\\\\\\\n\\\\\\n        if lang not in SupportedLanguage.values():\\\\\\\\\n            raise ValueError("Language {lang} is not supported. Must be one of {SupportedLanguage.values()}")\\\\\\\\n\\\\\\n        if not image and not dockerfile:\\\\\\\n            image = DefaultImage.__dict__[lang.upper()]\\\\\\\n\\\\\\n        self.lang: str = lang\\\\n        self.client: DockerClient = DockerClient()\\\\n        self.image: Union[Image, str] = image\\\\n        self.dockerfile: Optional[str] = dockerfile\\\\n        self.container: Optional[Container] = None\\\\n        self.keep_template: bool = keep_template\\\\n        self.verbose: bool = verbose\\\\n        self.path: Optional[str] = None\\\\n        self.is_create_template: bool = False\\\\n\\\\\\n    def open(self):\\\\\\\\n        warning_str = (\\",\\\".join([\\\"Since the `keep_template` flag is set to True the docker image will not be removed after the session ends \\\"\\n            \\\"and remains for future use.\\\"]))\\\\\\\\n        if self.dockerfile:\\\\\\\n            self.path = os.path.dirname(self.dockerfile)\\\\\\\n            if self.verbose:\\\\\\\n                f_str = f"Building docker image from {self.dockerfile}"\\\\\\\n                f_str = f"{f_str}\n{warning_str}" if self.keep_template else f_str\\\\\\\n                print(f_str)\\\\\\\n\\\\\\n            self.image, _ = self.client.images.build(path=self.path,\\\\\\\n                dockerfile=os.path.basename(self.dockerfile), tag="sandbox")\\\\\\\n            self.is_create_template = True\\\\\\\n\\\\\\n        if isinstance(self.image, str):\\\\\\\\n            if not image_exists(self.client, self.image):\\\\\\\\n                if self.verbose:\\\\\\\n                    f_str = f"Pulling image {self.image}.."\\\\\\\n                    f_str = f"{f_str}\n{warning_str}" if self.keep_template else f_str\\\\\\\n                    print(f_str)\\\\\\\n\\\\\\n                self.image = self.client.images.pull(self.image)\\\\\\\n                self.is_create_template = True\\\\\\\n            else:\\\\\\\n                self.image = self.client.images.get(self.image)\\\\\\\n                if self.verbose:\\\\\\\n                    print(f"Using image {self.image.tags[-1]}")\\\\\\\n\\\\\\n        self.container = self.client.containers.run(self.image, detach=True, tty=True)\\\\\\\n\\\\\\n    def close(self):\\\\\\\\n        if self.container:\\\\\\\n            if isinstance(self.image, Image):\\\\\\\\\\n                self.container.commit(self.image.tags[-1])\\\\\\\n\\\\\\n            self.container.remove(force=True)\\\\\\\n            self.container = None\\\\\\\n\\\\\\n        if self.is_create_template and not self.keep_template:\\\\\\\n            containers = self.client.containers.list(all=True)\\\\\\\n            image_id = (self.image.id if isinstance(self.image, Image) else self.client.images.get(self.image).id)\\\\\\\n            image_in_use = any(container.image.id == image_id for container in containers)\\\\\\\n\\\\\\n            if not image_in_use:\\\\\\\n                if isinstance(self.image, str):\\\\\\\\n                    self.client.images.remove(self.image)\\\\\\\n                elif isinstance(self.image, Image):\\\\\\\\n                    self.image.remove(force=True)\\\\\\\n                else:\\\\\\\n                    raise ValueError("Invalid image type")\\\\\\\n            else:\\\\\\\n                if self.verbose:\\\\\\\n                    print("Image {self.image.tags[-1]} is in use by other containers. Skipping removal..")\\\\\\\n\\\\\\n    def run(self, code: str, libraries: Optional[List[str]] = None):\\\\\\\\n        if not self.container:\\\\\\\n            raise RuntimeError("Session is not open. Please call open() method before running code.")\\\\\\\n\\\\\\n        if libraries:\\\\\\\n            if self.lang.upper() in NotSupportedLibraryInstallation:\\\\\\\n                raise ValueError("Library installation has not been supported for {self.lang} yet!")\\\\\\\n\\\\\\n            command = get_libraries_installation_command(self.lang, libraries)\\\\\\\n            self.execute_command(command)\\\\\\\n\\\\\\n        code_file = f"/tmp/code.{get_code_file_extension(self.lang)}"\\\\\\\n        with open(code_file, "w") as f:\\\\\\\n            f.write(code)\\\\\\\n\\\\\\n        self.copy_to_runtime(code_file, code_file)\\\\\\\n        result = self.execute_command(get_code_execution_command(self.lang, code_file))\\\\\\\n        return result\\\\\\\n\\\\\\n    def copy_from_runtime(self, src: str, dest: str):\\\\\\\\n        if not self.container:\\\\\\\n            raise RuntimeError("Session is not open. Please call open() method before copying files.")\\\\\\\n\\\\\\n        if self.verbose:\\\\\\\n            print(f"Copying {self.container.short_id}:{src} to {dest}..")\\\\\\\n\\\\\\n        bits, stat = self.container.get_archive(src)\\\\\\\n        if stat["size"] == 0:\\\\\\\n            raise FileNotFoundError(f"File {src} not found in the container")\\\\\\\n\\\\\\n        tarstream = io.BytesIO(b""\.join(bits))\\\\\\\n        with tarfile.open(fileobj=tarstream, mode="r") as tar:\\\\\\\n            tar.extractall(os.path.dirname(dest))\\\\\\\n\\\\\\n    def copy_to_runtime(self, src: str, dest: str):\\\\\\\\n        if not self.container:\\\\\\\n            raise RuntimeError("Session is not open. Please call open() method before copying files.")\\\\\\\n\\\\\\n        is_created_dir = False\\\\\\\n        directory = os.path.dirname(dest)\\\\\\\n        if directory:\\\\\\\n            self.container.exec_run(f"mkdir -p {directory}")\\\\\\\n            is_created_dir = True\\\\\\\n\\\\\\n        if self.verbose:\\\\\\\n            if is_created_dir:\\\\\\\n                print(f"Creating directory {self.container.short_id}:{directory}")\\\\\\\n            print(f"Copying {src} to {self.container.short_id}:{dest}..")\\\\\\\n\\\\\\n        tarstream = io.BytesIO()\\\\\\\n        with tarfile.open(fileobj=tarstream, mode="w") as tar:\\\\\\\n            tar.add(src, arcname=os.path.basename(src))\\\\\\\n\\\\\\n        tarstream.seek(0)\\\\\\\n        self.container.put_archive(os.path.dirname(dest), tarstream)\\\\\\\n\\\\\\n    def execute_command(self, command: str):\\\\\\\\n        if not command:\\\\\\\n            raise ValueError("Command cannot be empty")\\\\\\\n\\\\\\n        if not self.container:\\\\\\\n            raise RuntimeError("Session is not open. Please call open() method before executing commands.")\\\\\\\n\\\\\\n        if self.verbose:\\\\\\\n            print(f"Executing command: {command}")\\\\\\\n\\\\\\n        _, exec_log = self.container.exec_run(command, stream=True)\\\\\\\n        output = ""\\\\\\\n\\\\\\n        if self.verbose:\\\\\\\n            print("Output:", end=" ")\\\\\\\n\\\\\\n        for chunk in exec_log:\\\\\\\n            chunk_str = chunk.decode("utf-8")\\\\\\\n            output += chunk_str\\\\\\\n            if self.verbose:\\\\\\\n                print(chunk_str, end="")\\\\\\\n\\\\\\n        return output\\\\\\\n\\\\\\n    def __enter__(self):\\\\\\\\n        self.open()\\\\\\\n        return self\\\\\\\n\\\\\\n    def __exit__(self, exc_type, exc_val, exc_tb):\\\\\\\\n        self.close()\\\\\\\n